<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Music Sync</title>
    <!-- Tailwind CSSをCDNで読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- QRコード生成ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <!-- html5-qrcodeライブラリを使用 -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }
        .container {
            background-color: white;
            padding: 2.5rem;
            border-radius: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
        }
        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            border: 2px dashed #9ca3af;
            border-radius: 1rem;
            color: #6b7280;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .file-input-label:hover {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        #fileInput {
            display: none;
        }
        #qrCodeHost, #qrCodeClient {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }
        /* スキャナーのビデオ要素のスタイル */
        #qr-reader-host__dashboard_section,
        #qr-reader-client__dashboard_section {
            padding: 0;
        }
        .code-box {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            word-break: break-all;
            white-space: pre-wrap;
            position: relative;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 0.5rem;
            height: 1.5rem;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #4f46e5;
            transition: width 0.3s ease-in-out;
        }
        /* トースト通知用のスタイル */
        #toastContainer {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            transform: translateY(20px);
            pointer-events: none;
        }
        #toastContainer.show-toast {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #toastMessage {
            background-color: rgba(30, 41, 59, 0.95);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            font-size: 0.875rem;
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="container space-y-6">
        <h1 class="text-3xl font-bold text-center text-indigo-700">WebRTC Music Sync</h1>
        <p class="text-center text-gray-600">
            みんなで音楽を同期して聴こう！
        </p>

        <!-- ロール選択セクション -->
        <div id="roleSelection" class="space-y-4">
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="startHostButton" class="flex-1 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition">ホストとして始める</button>
                <button id="startClientButton" class="flex-1 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition">参加者として参加</button>
            </div>
            <!-- デバッグ用ボタン -->
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mt-4">
                <button id="debugHostButton" class="flex-1 px-6 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition">デバッグモード (ホスト)</button>
                <button id="debugClientButton" class="flex-1 px-6 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition">デバッグモード (参加者)</button>
            </div>
        </div>

        <!-- メインアプリセクション (最初は非表示) -->
        <div id="mainApp" class="hidden space-y-6">
            <!-- 接続ステータス表示 -->
            <div class="p-4 bg-gray-50 border border-gray-200 rounded-xl">
                <p id="connectionStatus" class="text-center font-medium">
                    接続していません
                </p>
                <p id="delayStatus" class="text-center text-sm text-gray-500 mt-2 hidden"></p>
            </div>

            <!-- ファイル入力セクション (ホストのみ) -->
            <div id="fileInputSection" class="hidden">
                <label for="fileInput" class="file-input-label">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <span>音楽ファイルをドラッグ＆ドロップまたはクリックで選択</span>
                </label>
                <input type="file" id="fileInput" accept="audio/*" class="hidden">
            </div>

            <!-- ファイル情報と再生コンポーネント -->
            <div id="fileInfo" class="hidden p-4 bg-indigo-50 border border-indigo-200 rounded-xl space-y-2">
                <p class="font-semibold text-indigo-700">選択したファイル:</p>
                <p id="fileName" class="text-gray-800 break-words"></p>
            </div>
            
            <audio id="audioPlayer" class="w-full hidden rounded-lg"></audio>
            
            <!-- プログレスバー -->
            <div id="progressBarContainer" class="hidden">
                <p class="text-sm text-center text-gray-600 mb-2">ファイル受信中...</p>
                <div class="progress-bar-container">
                    <div id="progressBar" class="progress-bar" style="width: 0%;"></div>
                </div>
            </div>

            <div id="clientPlaybackStatus" class="hidden text-center text-gray-600 font-medium">
                ホストが再生を開始するのを待っています...
            </div>
            
            <!-- ホスト再生コントロール -->
            <div id="hostPlaybackControls" class="hidden flex justify-center space-x-4">
                <button id="playButton" disabled class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <button id="pauseButton" disabled class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                </button>
            </div>

            <!-- 参加者再生コントロール -->
            <div id="clientPlaybackControls" class="hidden flex justify-center space-x-4">
                <button id="clientReadyButton" disabled class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                    再生準備完了
                </button>
            </div>


            <!-- 操作ボタン -->
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mt-6">
                <button id="disconnectButton" disabled class="flex-1 w-full sm:w-auto px-6 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-200 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                    接続を切断
                </button>
            </div>

            <!-- ホストセクション -->
            <div id="hostSection" class="hidden space-y-4">
                <div class="p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2">
                        参加者に見せてスキャンしてもらってください:
                    </p>
                    <div id="qrCodeHost" class="p-2 border border-gray-300 rounded-lg"></div>
                    <div class="mt-4 flex items-center space-x-2">
                        <input id="hostCode" type="text" readonly class="flex-1 p-2 rounded-lg border border-gray-300 text-sm bg-gray-100" />
                        <button id="copyHostCodeButton" class="bg-indigo-500 text-white p-2 rounded-lg text-sm hover:bg-indigo-600 transition">コピー</button>
                    </div>
                </div>
                
                <div class="p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2">
                        参加者のQRコードをスキャンして接続:
                    </p>
                    <div class="mt-2 text-center">
                        <label for="cameraSelectHost" class="text-sm font-medium text-gray-700">使用するカメラを選択:</label>
                        <select id="cameraSelectHost" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></select>
                        <button id="scanButtonHost" class="w-full mt-2 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition">
                            スキャンして接続
                        </button>
                        <!-- スキャナーのコンテナ -->
                        <div id="qr-reader-host" class="hidden mt-4"></div>
                    </div>
                </div>
                
                <div class="p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2">
                        または、参加者のコードを貼り付けて接続:
                    </p>
                    <textarea id="pasteClientCode" class="w-full h-24 p-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring focus:ring-indigo-200 focus:border-indigo-300"></textarea>
                    <button id="connectWithClientCodeButton" class="w-full mt-2 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition">
                        コードで接続
                    </button>
                </div>
            </div>

            <!-- 参加者セクション -->
            <div id="clientSection" class="hidden space-y-4">
                <div class="p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2">
                        ホストのQRコードをスキャンしてください:
                    </p>
                    <div class="mt-2 text-center">
                        <label for="cameraSelectClient" class="text-sm font-medium text-gray-700">使用するカメラを選択:</label>
                        <select id="cameraSelectClient" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></select>
                        <button id="scanButtonClient" class="w-full mt-2 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition">
                            スキャンして回答を生成
                        </button>
                        <!-- スキャナーのコンテナ -->
                        <div id="qr-reader-client" class="hidden mt-4"></div>
                    </div>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2">
                        または、ホストのコードを貼り付けて回答を生成:
                    </p>
                    <textarea id="pasteHostCode" class="w-full h-24 p-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring focus:ring-indigo-200 focus:border-indigo-300"></textarea>
                    <button id="createAnswerWithHostCodeButton" class="w-full mt-2 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition">
                        コードで回答を生成
                    </button>
                </div>

                <div id="qrCodeClientSection" class="p-4 bg-gray-50 rounded-lg hidden">
                    <p class="text-sm font-medium text-center text-gray-500 mb-2" id="qrClientTitle">
                        生成されたQRコードをホストに見せてください:
                    </p>
                    <div id="qrCodeClient" class="p-2 border border-gray-300 rounded-lg"></div>
                    <div class="mt-4 flex items-center space-x-2">
                        <input id="clientCode" type="text" readonly class="flex-1 p-2 rounded-lg border border-gray-300 text-sm bg-gray-100" />
                        <button id="copyClientCodeButton" class="bg-indigo-500 text-white p-2 rounded-lg text-sm hover:bg-indigo-600 transition">コピー</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- トースト通知用のコンテナ -->
    <div id="toastContainer">
        <div id="toastMessage"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // UI要素の取得
            const roleSelection = document.getElementById('roleSelection');
            const mainApp = document.getElementById('mainApp');
            const startHostButton = document.getElementById('startHostButton');
            const startClientButton = document.getElementById('startClientButton');
            const debugHostButton = document.getElementById('debugHostButton');
            const debugClientButton = document.getElementById('debugClientButton');
            
            const fileInput = document.getElementById('fileInput');
            const fileInputSection = document.getElementById('fileInputSection');
            const fileInfoDiv = document.getElementById('fileInfo');
            const fileNameSpan = document.getElementById('fileName');
            const audioPlayer = document.getElementById('audioPlayer');
            const clientPlaybackStatus = document.getElementById('clientPlaybackStatus');
            const connectionStatus = document.getElementById('connectionStatus');
            const delayStatus = document.getElementById('delayStatus');
            const disconnectButton = document.getElementById('disconnectButton');
            
            const hostSection = document.getElementById('hostSection');
            const qrCodeHost = document.getElementById('qrCodeHost');
            const scanButtonHost = document.getElementById('scanButtonHost');
            const cameraSelectHost = document.getElementById('cameraSelectHost');
            const qrReaderHostDiv = document.getElementById('qr-reader-host');
            const hostPlaybackControls = document.getElementById('hostPlaybackControls');
            const playButton = document.getElementById('playButton');
            const pauseButton = document.getElementById('pauseButton');
            const hostCodeInput = document.getElementById('hostCode');
            const copyHostCodeButton = document.getElementById('copyHostCodeButton');
            const pasteClientCodeTextarea = document.getElementById('pasteClientCode');
            const connectWithClientCodeButton = document.getElementById('connectWithClientCodeButton');
            
            const clientSection = document.getElementById('clientSection');
            const scanButtonClient = document.getElementById('scanButtonClient');
            const cameraSelectClient = document.getElementById('cameraSelectClient');
            const qrReaderClientDiv = document.getElementById('qr-reader-client');
            const qrCodeClient = document.getElementById('qrCodeClient');
            const qrCodeClientSection = document.getElementById('qrCodeClientSection');
            const qrClientTitle = document.getElementById('qrClientTitle');
            const pasteHostCodeTextarea = document.getElementById('pasteHostCode');
            const createAnswerWithHostCodeButton = document.getElementById('createAnswerWithHostCodeButton');
            const clientCodeInput = document.getElementById('clientCode');
            const copyClientCodeButton = document.getElementById('copyClientCodeButton');
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressBar = document.getElementById('progressBar');
            
            // 追加されたUI要素
            const clientPlaybackControls = document.getElementById('clientPlaybackControls');
            const clientReadyButton = document.getElementById('clientReadyButton');

            // トースト通知のUI要素
            const toastContainer = document.getElementById('toastContainer');
            const toastMessage = document.getElementById('toastMessage');

            // WebRTC ICEサーバー設定
            const iceServers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                ]
            };

            // アプリケーションの状態変数
            let peerConnection = null;
            let dataChannel = null;
            let fileData = null;
            let fileMimeType = null;
            let isHost = false;
            let isConnected = false;
            let hostScanner = null;
            let clientScanner = null;
            let totalFileSize = 0;
            let receivedSize = 0;
            let isTransferring = false; // 転送中かどうかのフラグ
            let estimatedDelay = 0; // 推定遅延時間 (ms)
            
            // ホスト側のファイル転送用変数
            let hostBase64Data = '';
            let hostChunkSize = 16 * 1024; // 16KB
            let hostChunkIndex = 0;

            /**
             * トースト通知を表示する関数
             * @param {string} message 通知メッセージ
             */
            function showToast(message) {
                toastMessage.textContent = message;
                toastContainer.classList.add('show-toast');
                setTimeout(() => {
                    toastContainer.classList.remove('show-toast');
                }, 3000); // 3秒後に非表示
            }
            
            /**
             * 利用可能なカメラデバイスを取得し、セレクトボックスに表示する
             */
            async function getDevicesAndPopulateSelectors() {
                try {
                    const devices = await Html5Qrcode.getCameras();
                    if (devices && devices.length > 0) {
                        devices.forEach(device => {
                            const optionHost = document.createElement('option');
                            optionHost.value = device.id;
                            optionHost.textContent = device.label || `Camera ${cameraSelectHost.length + 1}`;
                            cameraSelectHost.appendChild(optionHost);

                            const optionClient = document.createElement('option');
                            optionClient.value = device.id;
                            optionClient.textContent = device.label || `Camera ${cameraSelectClient.length + 1}`;
                            cameraSelectClient.appendChild(optionClient);
                        });
                    } else {
                        showToast('エラー: カメラが見つかりませんでした。');
                    }
                } catch (e) {
                    showToast('エラー: カメラへのアクセス権限がありません。');
                    console.error('getCameras() error:', e);
                }
            }

            /**
             * QRコードスキャナーを停止する
             * @param {object} scanner 停止するスキャナーインスタンス
             */
            function stopScanner(scanner) {
                if (scanner && scanner.getState() === 2) { // Html5QrcodeScannerState.SCANNING
                    scanner.stop().catch(err => {
                        console.error("Failed to stop scanner:", err);
                    });
                }
            }
            
            /**
             * ホスト側で次のファイルチャンクを送信する関数
             */
            function sendNextChunk() {
                if (!isTransferring) return;

                const start = hostChunkIndex * hostChunkSize;
                const end = Math.min(start + hostChunkSize, hostBase64Data.length);
                const chunk = hostBase64Data.slice(start, end);
                const isLast = (end === hostBase64Data.length);

                if (dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'audio_chunk',
                        chunk: chunk,
                        index: hostChunkIndex,
                        isLast: isLast
                    }));
                    
                    if (isLast) {
                        isTransferring = false;
                        hostChunkIndex = 0; // 転送完了後、インデックスをリセット
                        console.log("File transfer complete!");
                        showToast('ファイル転送が完了しました。');
                    } else {
                        hostChunkIndex++;
                    }
                }
            }

            /**
             * WebRTC PeerConnectionを初期化する
             */
            function createPeerConnection() {
                peerConnection = new RTCPeerConnection(iceServers);
                
                // ICE候補が生成されたときのイベント
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        // シンプルにするため、ギャザリング完了後にまとめて処理
                    }
                };
                
                // ICEギャザリングが完了したときのイベント
                peerConnection.onicegatheringstatechange = () => {
                    console.log(`ICE gathering state: ${peerConnection.iceGatheringState}`);
                    if (peerConnection.iceGatheringState === 'complete') {
                        console.log('ICE gathering complete');
                        if (isHost) {
                            const offerSdp = JSON.stringify(peerConnection.localDescription);
                            const qr = qrcode(0, 'L');
                            qr.addData(offerSdp);
                            qr.make();
                            qrCodeHost.innerHTML = qr.createImgTag(5);
                            hostCodeInput.value = offerSdp;
                            showToast('ホストの接続情報が生成されました。自動的にコードがコピーされました。');
                            navigator.clipboard.writeText(offerSdp);
                            stopScanner(hostScanner);
                        } else {
                            const answerSDP = JSON.stringify(peerConnection.localDescription);
                            const qr = qrcode(0, 'L');
                            qr.addData(answerSDP);
                            qr.make();
                            qrCodeClient.innerHTML = qr.createImgTag(5);
                            clientCodeInput.value = answerSDP;
                            qrCodeClientSection.classList.remove('hidden');
                            showToast('回答情報が生成されました。自動的にコードがコピーされました。');
                            navigator.clipboard.writeText(answerSDP);
                            stopScanner(clientScanner);
                        }
                    }
                };

                // 接続状態が変化したときのイベント
                peerConnection.onconnectionstatechange = () => {
                    console.log(`Connection state: ${peerConnection.connectionState}`);
                    if (peerConnection.connectionState === 'connected') {
                        isConnected = true;
                        connectionStatus.textContent = '接続済み';
                        disconnectButton.disabled = false;
                        if(isHost) {
                            showToast('参加者と接続しました。音楽を再生してください。');
                            hostSection.classList.add('hidden');
                        } else {
                            showToast('ホストと接続しました。ホストからの音楽ファイルの受信を待機します。');
                            clientSection.classList.add('hidden');
                        }
                    } else {
                        isConnected = false;
                        connectionStatus.textContent = '切断済み';
                        disconnectButton.disabled = true;
                        playButton.disabled = true;
                        pauseButton.disabled = true;
                    }
                };
                
                // ICE接続状態が変化したときのイベント
                peerConnection.oniceconnectionstatechange = () => {
                    console.log(`ICE connection state: ${peerConnection.iceConnectionState}`);
                    if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
                        connectionStatus.textContent = '接続が切断されました';
                        disconnectButton.disabled = true;
                        if(isHost) {
                            showToast('参加者との接続が切断されました。');
                        } else {
                            showToast('ホストとの接続が切断されました。');
                        }
                    }
                };
            }

            // ホストとして始めるボタン
            startHostButton.addEventListener('click', async () => {
                isHost = true;
                roleSelection.classList.add('hidden');
                mainApp.classList.remove('hidden');
                fileInputSection.classList.remove('hidden');
                hostSection.classList.remove('hidden');
                connectionStatus.textContent = '待機中...';
                
                createPeerConnection();

                // ホスト側でデータチャネルを作成
                dataChannel = peerConnection.createDataChannel('audio-sync');
                dataChannel.onopen = () => { 
                    console.log('Data Channel is open!'); 
                    if (isHost) {
                        // 接続確立後、遅延測定を開始
                        delayStatus.classList.remove('hidden');
                        delayStatus.textContent = '遅延を測定中...';
                        dataChannel.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
                    }
                };
                dataChannel.onmessage = async (event) => {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'requestAudio') {
                        if (fileData) {
                            isTransferring = true;
                            hostBase64Data = fileData.split(',')[1];
                            const totalFileSize = hostBase64Data.length;
                            const mimeType = fileMimeType;
                            hostChunkIndex = 0;
                            
                            // まず総サイズとMIMEタイプを送信
                            dataChannel.send(JSON.stringify({
                                type: 'fileSize',
                                size: totalFileSize,
                                mimeType: mimeType
                            }));
                            
                            // 最初のチャンクを送信
                            sendNextChunk();
                            
                        } else {
                            showToast('エラー: 音楽ファイルを選択してください。');
                        }
                    } else if (message.type === 'chunk_received') {
                         // 参加者から次のチャンクの送信リクエストを受信
                         if (isTransferring) {
                            sendNextChunk();
                         }
                    } else if (message.type === 'clientReady') {
                        // 参加者からの「再生準備完了」通知を受信
                        showToast("参加者が再生準備を完了しました。再生を開始してください。");
                    } else if (message.type === 'pong') {
                        // 参加者からの応答を受信し、遅延を計算
                        const now = Date.now();
                        const rtt = now - message.host_timestamp;
                        estimatedDelay = Math.floor(rtt / 2);
                        delayStatus.textContent = `推定遅延: ${estimatedDelay}ms`;
                        playButton.disabled = false;
                        pauseButton.disabled = false;
                        showToast(`遅延測定が完了しました。推定遅延: ${estimatedDelay}ms`);
                    }
                };
                dataChannel.onclose = () => { console.log('Data Channel is closed.'); };
                dataChannel.onerror = (error) => { console.error('Data Channel Error:', error); };

                // オファーを作成してローカルディスクリプションに設定
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    showToast('オファーが生成されました。');
                } catch (e) {
                    console.error('Failed to create or set offer:', e);
                    showToast('エラー: オファーの生成に失敗しました。');
                }
            });

            // 参加者として参加ボタン
            startClientButton.addEventListener('click', () => {
                isHost = false;
                roleSelection.classList.add('hidden');
                mainApp.classList.remove('hidden');
                clientSection.classList.remove('hidden');
                connectionStatus.textContent = '待機中...';
                
                createPeerConnection();

                // 参加者側でデータチャネルを受信
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    let receivedChunks = [];
                    dataChannel.onopen = () => {
                        console.log('Data Channel is open!');
                        // 接続が確立したら、ホストに音楽ファイルの要求を送信
                        dataChannel.send(JSON.stringify({ type: 'requestAudio' }));
                    };
                    dataChannel.onmessage = async (event) => {
                        const message = JSON.parse(event.data);
                        if (message.type === 'fileSize') {
                            totalFileSize = message.size;
                            fileMimeType = message.mimeType;
                            receivedSize = 0; // 新しい転送のためにリセット
                            progressBar.style.width = '0%';
                            progressBarContainer.classList.remove('hidden');
                            clientPlaybackStatus.classList.remove('hidden'); // ステータスを表示
                            clientPlaybackStatus.textContent = 'ホストから音楽ファイルを受信中...';
                            showToast('ホストから音楽ファイルを受信中です...');
                        } else if (message.type === 'audio_chunk') {
                            receivedChunks.push(message.chunk);
                            receivedSize += message.chunk.length;
                            const progress = (receivedSize / totalFileSize) * 100;
                            progressBar.style.width = `${progress}%`;
                            
                            if (message.isLast) {
                                progressBarContainer.classList.add('hidden');
                                receivedSize = 0;
                                const base64Data = receivedChunks.join('');
                                fileData = `data:${fileMimeType};base64,${base64Data}`;
                                audioPlayer.src = fileData;
                                audioPlayer.classList.remove('hidden');
                                fileInfoDiv.classList.remove('hidden');
                                fileNameSpan.textContent = '受信したファイル';
                                showToast('ホストから音楽ファイルを受信しました。');
                                
                                // ファイル受信完了後、再生コントロールを表示
                                clientPlaybackControls.classList.remove('hidden');
                                clientReadyButton.disabled = false;
                                clientPlaybackStatus.textContent = '再生準備が完了しました。';
                                receivedChunks = [];
                            } else {
                                // 受信確認をホストに送信
                                dataChannel.send(JSON.stringify({ type: 'chunk_received', index: message.index }));
                            }
                        } else if (message.type === 'sync') {
                            // 参加者はホストのコマンドをリッスン
                            if (message.action === 'play') {
                                // 遅延を計算して再生をスケジュール
                                const delay = message.start_timestamp - Date.now();
                                if (delay > 0) {
                                    setTimeout(() => audioPlayer.play(), delay);
                                    clientPlaybackStatus.textContent = `再生をスケジュール中 (${delay}ms)...`;
                                } else {
                                    audioPlayer.play();
                                    clientPlaybackStatus.textContent = '再生中';
                                }
                            } else if (message.action === 'pause') {
                                audioPlayer.pause();
                                clientPlaybackStatus.textContent = '一時停止中';
                            }
                        }
                    };
                    dataChannel.onclose = () => {
                        console.log('Data Channel is closed.');
                        showToast('ホストとの接続が切断されました。');
                    };
                    dataChannel.onerror = (error) => { console.error('Data Channel Error:', error); };
                };
            });
            
            // ホストの再生ボタンのイベントリスナー
            playButton.addEventListener('click', () => {
                if (isConnected && dataChannel && dataChannel.readyState === 'open' && !isTransferring && fileData) {
                    const startTimestamp = Date.now() + estimatedDelay;
                    audioPlayer.play();
                    // 参加者への再生指示を送信
                    dataChannel.send(JSON.stringify({ type: 'sync', action: 'play', start_timestamp: startTimestamp }));
                } else if (isTransferring) {
                    showToast('ファイル転送中です。完了までお待ちください。');
                } else if (!fileData) {
                    showToast('音楽ファイルを選択してください。');
                }
            });

            // ホストの再生・一時停止ボタンのイベントリスナーを設定
            pauseButton.addEventListener('click', () => {
                if (isConnected && dataChannel && dataChannel.readyState === 'open') {
                    audioPlayer.pause();
                    dataChannel.send(JSON.stringify({ type: 'sync', action: 'pause' }));
                }
            });

            // 参加者側の再生準備ボタンのイベントリスナーを設定
            clientReadyButton.addEventListener('click', () => {
                // ブラウザの自動再生ポリシーを解除するため、一度再生してすぐに一時停止する
                audioPlayer.play().then(() => {
                    audioPlayer.pause();
                    
                    // ホストに「再生準備ができました」と通知
                    if (isConnected && dataChannel && dataChannel.readyState === 'open') {
                        showToast("ホストの再生指示を待っています...");
                        clientReadyButton.textContent = '待機中...';
                        clientReadyButton.disabled = true;
                        dataChannel.send(JSON.stringify({ type: 'clientReady' }));
                    }

                }).catch(e => {
                    console.error("Autoplay was prevented:", e);
                    showToast("エラー: ブラウザの自動再生がブロックされました。手動で再生を開始してください。");
                });
            });
            
            // ファイル入力イベント
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        fileData = event.target.result;
                        fileMimeType = file.type;
                        fileInfoDiv.classList.remove('hidden');
                        fileNameSpan.textContent = file.name;
                        audioPlayer.src = URL.createObjectURL(file);
                        audioPlayer.classList.remove('hidden');
                        hostPlaybackControls.classList.remove('hidden');
                        playButton.disabled = true;
                        pauseButton.disabled = true;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // 切断ボタン
            disconnectButton.addEventListener('click', () => {
                if (peerConnection) {
                    peerConnection.close();
                }
                stopScanner(hostScanner);
                stopScanner(clientScanner);
                window.location.reload();
            });

            // ホスト側のQRコードスキャンボタン
            scanButtonHost.addEventListener('click', async () => {
                qrReaderHostDiv.classList.remove('hidden');
                const selectedCameraId = cameraSelectHost.value;
                hostScanner = new Html5Qrcode('qr-reader-host');
                
                // カメラの解像度を指定するオプションを追加
                const config = {
                    fps: 10,
                    qrbox: { width: 250, height: 250 },
                    // ここでビデオの解像度を定義
                    videoConstraints: {
                        facingMode: 'environment', // スマートフォンでは背面カメラを優先
                        width: { ideal: 1280 }, // 希望の幅
                        height: { ideal: 720 }  // 希望の高さ
                    }
                };

                hostScanner.start(
                    selectedCameraId,
                    config, // 修正したconfigを渡す
                    (decodedText, decodedResult) => {
                        // 成功コールバック
                        hostScanner.stop().then(() => {
                            try {
                                const remoteAnswer = JSON.parse(decodedText);
                                peerConnection.setRemoteDescription(new RTCSessionDescription(remoteAnswer));
                                showToast('参加者と接続しました！');
                            } catch (e) {
                                showToast('エラー: 無効なQRコードです。');
                                console.error('Failed to set remote answer:', e);
                            }
                        }).catch(err => {
                            console.error("Failed to stop scanner after success:", err);
                        });
                    },
                    (errorMessage) => {
                        // エラーコールバック（リアルタイムでQRが見つからない場合）
                    }
                ).catch(err => {
                    showToast('エラー: カメラの起動に失敗しました。アクセスを許可してください。');
                    console.error("Camera start failed:", err);
                });
            });

            // 参加者側のQRコードスキャンボタン
            scanButtonClient.addEventListener('click', async () => {
                qrReaderClientDiv.classList.remove('hidden');
                const selectedCameraId = cameraSelectClient.value;
                clientScanner = new Html5Qrcode('qr-reader-client');
                
                // カメラの解像度を指定するオプションを追加
                const config = {
                    fps: 10,
                    qrbox: { width: 250, height: 250 },
                    // ここでビデオの解像度を定義
                    videoConstraints: {
                        facingMode: 'environment', // スマートフォンでは背面カメラを優先
                        width: { ideal: 1280 }, // 希望の幅
                        height: { ideal: 720 }  // 希望の高さ
                    }
                };

                clientScanner.start(
                    selectedCameraId,
                    config, // 修正したconfigを渡す
                    (decodedText, decodedResult) => {
                        // 成功コールバック
                        clientScanner.stop().then(async () => {
                            try {
                                const remoteOffer = JSON.parse(decodedText);
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(remoteOffer));
                                
                                const answer = await peerConnection.createAnswer();
                                await peerConnection.setLocalDescription(answer);
                                
                                showToast('回答情報が生成されました。');
                            } catch (e) {
                                showToast('エラー: 無効なQRコードです。');
                                console.error('Failed to set remote offer:', e);
                            }
                        }).catch(err => {
                            console.error("Failed to stop scanner after success:", err);
                        });
                    },
                    (errorMessage) => {
                        // エラーコールバック
                    }
                ).catch(err => {
                    showToast('エラー: カメラの起動に失敗しました。アクセスを許可してください。');
                    console.error("Camera start failed:", err);
                });
            });

            // ホスト側のコードコピーボタン
            copyHostCodeButton.addEventListener('click', () => {
                hostCodeInput.select();
                document.execCommand('copy');
                showToast('ホストの接続コードをクリップボードにコピーしました。');
            });

            // 参加者側のコード貼り付けボタン
            connectWithClientCodeButton.addEventListener('click', async () => {
                const remoteAnswerCode = pasteClientCodeTextarea.value;
                if (remoteAnswerCode) {
                    try {
                        const remoteAnswer = JSON.parse(remoteAnswerCode);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(remoteAnswer));
                        showToast('参加者と接続しました！');
                    } catch (e) {
                        showToast('エラー: 無効な接続コードです。');
                        console.error('Failed to set remote answer from code:', e);
                    }
                } else {
                    showToast('エラー: 接続コードを貼り付けてください。');
                }
            });

            // 参加者側のコードコピーボタン
            copyClientCodeButton.addEventListener('click', () => {
                clientCodeInput.select();
                document.execCommand('copy');
                showToast('回答コードをクリップボードにコピーしました。');
            });

            // ホスト側のコード貼り付けボタン
            createAnswerWithHostCodeButton.addEventListener('click', async () => {
                const remoteOfferCode = pasteHostCodeTextarea.value;
                if (remoteOfferCode) {
                    try {
                        const remoteOffer = JSON.parse(remoteOfferCode);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(remoteOffer));
                        
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        showToast('回答情報が生成されました。');
                    } catch (e) {
                        showToast('エラー: 無効な接続コードです。');
                        console.error('Failed to set remote offer from code:', e);
                    }
                } else {
                    showToast('エラー: ホストのコードを貼り付けてください。');
                }
            });
            
            /**
             * デバッグモードに移行する関数
             * @param {'host' | 'client'} role - 移行するロール ('host' または 'client')
             */
            function enterDebugMode(role) {
                isHost = (role === 'host');
                
                // UIをリセット
                roleSelection.classList.add('hidden');
                mainApp.classList.remove('hidden');
                hostSection.classList.add('hidden');
                clientSection.classList.add('hidden');
                fileInputSection.classList.add('hidden');
                hostPlaybackControls.classList.add('hidden');
                clientPlaybackControls.classList.add('hidden');
                progressBarContainer.classList.add('hidden');
                clientPlaybackStatus.classList.add('hidden');

                // 状態を「接続済み」に設定
                isConnected = true;
                connectionStatus.textContent = `デバッグモード (${role === 'host' ? 'ホスト' : '参加者'})`;
                disconnectButton.disabled = false;

                if (isHost) {
                    fileInputSection.classList.remove('hidden');
                    hostPlaybackControls.classList.remove('hidden');
                    playButton.disabled = false;
                    pauseButton.disabled = false;
                    delayStatus.classList.remove('hidden');
                    delayStatus.textContent = '推定遅延: 0ms (デバッグ)';
                } else {
                    clientPlaybackControls.classList.remove('hidden');
                    clientReadyButton.disabled = false;
                    fileInfoDiv.classList.remove('hidden');
                    fileNameSpan.textContent = 'デバッグ用ファイル';
                    audioPlayer.classList.remove('hidden');
                    audioPlayer.src = 'data:audio/mp3;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // ダミーのオーディオデータ
                    clientPlaybackStatus.classList.remove('hidden');
                    clientPlaybackStatus.textContent = '再生準備完了';
                }
                
                showToast(`デバッグモード (${role === 'host' ? 'ホスト' : '参加者'}) に移行しました。`);
            }
            
            // デバッグボタンのイベントリスナー
            debugHostButton.addEventListener('click', () => {
                enterDebugMode('host');
            });

            debugClientButton.addEventListener('click', () => {
                enterDebugMode('client');
            });


            // ページ読み込み時にカメラデバイスを列挙
            getDevicesAndPopulateSelectors();
        });
    </script>
</body>
</html>
