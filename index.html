<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC音楽同期サイト</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            background-color: #2d3748;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        .title {
            font-size: 2rem;
            font-weight: 600;
            color: #48bb78;
            margin-bottom: 1rem;
        }
        .subtitle {
            color: #a0aec0;
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #cbd5e0;
        }
        .btn {
            background-color: #48bb78;
            color: #1a202c;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(72, 187, 120, 0.4);
        }
        .input-field {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            margin-top: 1rem;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #48bb78;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
            display: none; /* Initially hidden */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container mx-auto p-8 rounded-2xl shadow-lg bg-gray-800">
        <h1 class="text-3xl font-bold text-green-400 mb-4">WebRTC 音楽同期サイト</h1>
        <p class="text-gray-400 mb-8">P2Pで音楽を同期再生します</p>

        <div class="space-y-6">
            <div class="p-6 bg-gray-700 rounded-xl">
                <h2 class="section-title">ホスト（再生を開始する人）</h2>
                <button id="hostButton" class="btn w-full">セッションを開始してURLを生成</button>
            </div>

            <div class="p-6 bg-gray-700 rounded-xl">
                <h2 class="section-title">クライアント（参加する人）</h2>
                <button id="clientButton" class="btn w-full">URLからセッションに参加</button>
            </div>
            
            <div class="p-6 bg-gray-700 rounded-xl">
                <h2 class="section-title">共有/入力用URL</h2>
                <input type="text" id="urlInput" readonly class="input-field cursor-pointer">
                <button id="copyButton" class="btn mt-4 w-full">URLをコピー</button>
            </div>
        </div>
        
        <div id="loader" class="loader"></div>
        <p id="statusMessage" class="mt-4 text-sm text-gray-300"></p>
        
        <!-- WebRTCで送信されるSDPをここに設定する -->
        <audio id="audioPlayer" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"></audio>
    </div>

    <script>
        const hostButton = document.getElementById('hostButton');
        const clientButton = document.getElementById('clientButton');
        const copyButton = document.getElementById('copyButton');
        const urlInput = document.getElementById('urlInput');
        const audioPlayer = document.getElementById('audioPlayer');
        const statusMessage = document.getElementById('statusMessage');
        const loader = document.getElementById('loader');

        let peerConnection;
        
        // STUNサーバー
        const iceServers = {
            'iceServers': [{
                'urls': 'stun:stun.l.google.com:19302'
            }]
        };

        // SDPをBase64でエンコード/デコード
        function encodeSdp(sdp) {
            return btoa(JSON.stringify(sdp));
        }

        function decodeSdp(base64) {
            return JSON.parse(atob(base64));
        }

        // P2P接続の初期化
        async function initializePeerConnection() {
            peerConnection = new RTCPeerConnection(iceServers);

            // データチャネルの作成（音楽再生の同期信号用）
            const dataChannel = peerConnection.createDataChannel("audio-sync");
            dataChannel.onopen = (event) => {
                statusMessage.textContent = 'P2P接続が確立しました。';
                loader.style.display = 'none';
                console.log("Data Channel is open.");
                
                // ホスト側が再生を開始
                if (window.location.hash.includes('host')) {
                    setTimeout(() => {
                        audioPlayer.play();
                        // 再生開始信号を送信
                        dataChannel.send('play');
                    }, 100);
                }
            };
            
            // データチャネルで信号を受信
            dataChannel.onmessage = (event) => {
                if (event.data === 'play') {
                    // クライアント側が信号を受信したら再生
                    audioPlayer.play();
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                statusMessage.textContent = `接続状態: ${peerConnection.iceConnectionState}`;
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // ICE候補はSDPに含めているため、ここでは特別な処理は不要
                }
            };
        }

        // URLからハッシュを解析して処理
        async function handleUrlHash() {
            const hash = window.location.hash;
            if (hash.startsWith('#offer=')) {
                // クライアント側としてSDP offerを処理
                statusMessage.textContent = 'ホストからのSDPを処理中...';
                loader.style.display = 'block';

                const offerData = hash.replace('#offer=', '');
                const decodedOffer = decodeSdp(offerData);

                initializePeerConnection();
                await peerConnection.setRemoteDescription(new RTCSessionDescription(decodedOffer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                const encodedAnswer = encodeSdp(peerConnection.localDescription);
                const returnUrl = `${window.location.href.split('#')[0]}#answer=${encodedAnswer}`;

                urlInput.value = returnUrl;
                statusMessage.textContent = '返送用URLが生成されました。このURLをホストに送ってください。';
                
            } else if (hash.startsWith('#answer=')) {
                // ホスト側としてSDP answerを処理
                statusMessage.textContent = 'クライアントからのSDPを処理中...';
                loader.style.display = 'block';

                const answerData = hash.replace('#answer=', '');
                const decodedAnswer = decodeSdp(answerData);

                initializePeerConnection();
                // ICE候補交換の完了を待ってからanswerを設定する
                await new Promise(resolve => {
                    const checkInterval = setInterval(() => {
                        if (peerConnection.localDescription) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(decodedAnswer));
                statusMessage.textContent = '接続確立中...';
            }
        }

        // ホスト側のSDP offer生成
        hostButton.onclick = async () => {
            statusMessage.textContent = 'SDPを生成中...';
            loader.style.display = 'block';
            
            initializePeerConnection();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // ICE候補がSDPにすべて含まれるまで待機
            await new Promise(resolve => {
                if (peerConnection.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    peerConnection.onicegatheringstatechange = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            resolve();
                        }
                    };
                }
            });

            const encodedOffer = encodeSdp(peerConnection.localDescription);
            const shareUrl = `${window.location.href.split('#')[0]}#offer=${encodedOffer}&role=host`;
            urlInput.value = shareUrl;
            statusMessage.textContent = 'URLが生成されました。コピーしてクライアントに送ってください。';
            loader.style.display = 'none';
        };

        // クライアント側の処理開始
        clientButton.onclick = async () => {
             handleUrlHash();
        };

        // URLコピー機能
        copyButton.onclick = () => {
            urlInput.select();
            document.execCommand('copy');
            statusMessage.textContent = 'URLをクリップボードにコピーしました！';
        };

        // ページ読み込み時にURLハッシュをチェック
        window.onload = () => {
            const hash = window.location.hash;
            if (hash.startsWith('#offer=') || hash.startsWith('#answer=')) {
                handleUrlHash();
            }
        };

    </script>
</body>
</html>
