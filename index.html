<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>同期音楽プレイヤー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 600px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #cbd5e1;
            border-radius: 9999px;
            height: 8px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -4px;
        }
        #audio-controls {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white shadow-xl rounded-2xl p-8 space-y-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">同期音楽プレイヤー</h1>

        <!-- Music and control section -->
        <div class="space-y-4">
            <div class="bg-gray-50 rounded-lg p-4 flex items-center justify-center">
                <p class="text-gray-600 text-lg" id="song-title">サンプル曲</p>
            </div>
            <div id="audio-controls" class="space-x-4">
                <button id="play-pause-btn" class="flex-shrink-0 bg-indigo-600 text-white p-3 rounded-full shadow-lg hover:bg-indigo-700 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                    <svg id="play-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                    <svg id="pause-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                </button>
                <div class="w-full flex items-center space-x-2">
                    <span id="current-time" class="text-sm text-gray-500">0:00</span>
                    <input type="range" id="seek-bar" class="w-full h-2 bg-gray-200 rounded-full appearance-none cursor-pointer" value="0">
                    <span id="duration" class="text-sm text-gray-500">0:00</span>
                </div>
            </div>
        </div>

        <div class="mt-8 space-y-4">
            <!-- Share link section -->
            <div>
                <label class="block text-gray-700 font-semibold mb-2">共有リンク</label>
                <div class="flex space-x-2">
                    <input type="text" id="share-link-input" class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" readonly>
                    <button id="copy-btn" class="bg-indigo-600 text-white p-3 rounded-lg shadow-md hover:bg-indigo-700 transition-colors duration-200">コピー</button>
                </div>
            </div>
            
            <!-- Connection status and logs -->
            <div>
                <label class="block text-gray-700 font-semibold mb-2">接続状態</label>
                <p id="connection-status" class="text-sm text-gray-600">待機中...</p>
            </div>
            <div>
                <label class="block text-gray-700 font-semibold mb-2">ログ</label>
                <textarea id="log-area" class="w-full h-32 p-3 border border-gray-300 rounded-lg bg-gray-50 text-gray-700 resize-none" readonly></textarea>
            </div>
        </div>
    </div>
    <script>
        // DOM要素
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const seekBar = document.getElementById('seek-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const shareLinkInput = document.getElementById('share-link-input');
        const copyBtn = document.getElementById('copy-btn');
        const connectionStatusEl = document.getElementById('connection-status');
        const logArea = document.getElementById('log-area');

        // Web Audio API
        let audioContext;
        let audioSource;
        let audioBuffer;
        let startTime = 0;
        let playbackTime = 0;
        let isPlaying = false;

        // WebRTC
        let peerConnection;
        let dataChannel;

        // 定数
        const STUN_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
        const localMusicFile = '/__static__/sample.mp3'; // デモ用のサンプル曲

        // UIユーティリティ関数
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logArea.value += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // 初期化処理
        window.onload = async () => {
            log('ページをロードしました。');
            try {
                // サンプル曲のロード
                const response = await fetch(localMusicFile);
                const arrayBuffer = await response.arrayBuffer();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                log('音楽ファイルを読み込みました。');
                durationEl.textContent = formatTime(audioBuffer.duration);
                seekBar.max = audioBuffer.duration;
            } catch (error) {
                log('音楽ファイルのロードに失敗しました: ' + error.message);
            }

            // URLからSDP情報を取得
            const params = new URLSearchParams(window.location.search);
            const offerSDP = params.get('offer');

            if (offerSDP) {
                log('URLからオファーSDPを検出しました。セッションに参加します...');
                // オファーSDPが存在する場合、セッションに参加
                await createPeerConnection();
                const remoteDescription = new RTCSessionDescription({
                    type: 'offer',
                    sdp: decodeURIComponent(offerSDP)
                });
                await peerConnection.setRemoteDescription(remoteDescription);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                const answerSDP = encodeURIComponent(peerConnection.localDescription.sdp);
                const newUrl = `${window.location.origin}${window.location.pathname}?answer=${answerSDP}`;
                shareLinkInput.value = newUrl;
                connectionStatusEl.textContent = '接続中...';
            } else {
                // オファーSDPが存在しない場合、セッションを作成
                log('新しいセッションを作成します。');
                await createPeerConnection();
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                const offerSDP = encodeURIComponent(peerConnection.localDescription.sdp);
                const shareUrl = `${window.location.origin}${window.location.pathname}?offer=${offerSDP}`;
                shareLinkInput.value = shareUrl;
                connectionStatusEl.textContent = 'セッション作成済み。リンクを共有してください。';
            }

            // アンサーSDPがURLに追加された場合の処理
            window.addEventListener('popstate', () => {
                const updatedParams = new URLSearchParams(window.location.search);
                const answerSDP = updatedParams.get('answer');
                if (answerSDP && peerConnection.remoteDescription?.type !== 'answer') {
                    handleAnswer(decodeURIComponent(answerSDP));
                }
            });
        };

        // WebRTCピア接続の作成
        async function createPeerConnection() {
            peerConnection = new RTCPeerConnection({ iceServers: STUN_SERVERS });
            log('WebRTC PeerConnectionを作成しました。');

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    log('ICE候補を生成しました。');
                    // ICE候補は共有する必要があるが、このデモではURLにSDPを埋め込むシンプルな方法のため、
                    // candidate情報はSDPに含まれるものと仮定する
                }
            };

            peerConnection.onconnectionstatechange = () => {
                log(`接続状態: ${peerConnection.connectionState}`);
                if (peerConnection.connectionState === 'connected') {
                    connectionStatusEl.textContent = '接続済み';
                    log('P2P接続が確立しました。');
                }
            };

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannelListeners();
                log('DataChannelを受信しました。');
            };

            // オファーを作成する側がDataChannelを作成
            const params = new URLSearchParams(window.location.search);
            if (!params.get('offer')) {
                dataChannel = peerConnection.createDataChannel('sync-channel');
                setupDataChannelListeners();
                log('DataChannelを作成しました。');
            }
        }

        // DataChannelリスナーの設定
        function setupDataChannelListeners() {
            dataChannel.onopen = () => log('DataChannelが開きました。');
            dataChannel.onclose = () => log('DataChannelが閉じました。');
            dataChannel.onmessage = (event) => {
                const message = JSON.parse(event.data);
                log(`メッセージを受信: ${JSON.stringify(message)}`);
                if (message.type === 'play') {
                    const { time } = message.payload;
                    startPlayback(time);
                } else if (message.type === 'pause') {
                    const { time } = message.payload;
                    pausePlayback(time);
                }
            };
        }

        // アンサーSDPの処理
        async function handleAnswer(answerSDP) {
            log('アンサーSDPを受信しました。');
            const remoteDescription = new RTCSessionDescription({
                type: 'answer',
                sdp: answerSDP
            });
            await peerConnection.setRemoteDescription(remoteDescription);
            log('リモートSDPを設定しました。');
        }

        // 音楽再生の開始
        function startPlayback(seekTime = 0) {
            if (isPlaying) {
                audioSource.stop();
                audioSource.disconnect();
            }
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(audioContext.destination);
            audioSource.start(0, seekTime);
            startTime = audioContext.currentTime - seekTime;
            isPlaying = true;
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
            updateSeekBar();
        }

        // 音楽再生の一時停止
        function pausePlayback(seekTime) {
            if (isPlaying) {
                audioSource.stop();
                audioSource.disconnect();
                playbackTime = seekTime;
                isPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        }

        // 再生時間の更新
        function updateSeekBar() {
            if (isPlaying) {
                const elapsedTime = audioContext.currentTime - startTime;
                seekBar.value = elapsedTime;
                currentTimeEl.textContent = formatTime(elapsedTime);
                requestAnimationFrame(updateSeekBar);
            } else {
                seekBar.value = playbackTime;
                currentTimeEl.textContent = formatTime(playbackTime);
            }
        }

        // UIイベントリスナー
        playPauseBtn.addEventListener('click', () => {
            if (dataChannel && dataChannel.readyState === 'open') {
                if (isPlaying) {
                    const pauseTime = audioContext.currentTime - startTime;
                    dataChannel.send(JSON.stringify({ type: 'pause', payload: { time: pauseTime } }));
                    pausePlayback(pauseTime);
                } else {
                    dataChannel.send(JSON.stringify({ type: 'play', payload: { time: playbackTime } }));
                    startPlayback(playbackTime);
                }
            } else {
                log('データチャンネルがまだ開いていません。接続が確立するまでお待ちください。');
            }
        });

        seekBar.addEventListener('change', () => {
            const newTime = parseFloat(seekBar.value);
            if (isPlaying) {
                // シーク操作を同期
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'play', payload: { time: newTime } }));
                }
                startPlayback(newTime);
            } else {
                playbackTime = newTime;
                currentTimeEl.textContent = formatTime(playbackTime);
            }
        });

        copyBtn.addEventListener('click', () => {
            shareLinkInput.select();
            document.execCommand('copy');
            copyBtn.textContent = 'コピーしました！';
            setTimeout(() => {
                copyBtn.textContent = 'コピー';
            }, 2000);
        });
    </script>
</body>
</html>
